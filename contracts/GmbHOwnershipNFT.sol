// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\n\n/**\n * @title GmbHOwnershipNFT\n * @dev NFT contract representing beneficial ownership in German GmbH property companies\n * @notice This contract documents beneficial ownership stakes, not investment securities\n */\ncontract GmbHOwnershipNFT is ERC721, ERC721Enumerable, AccessControl, Pausable, ReentrancyGuard {\n    using Counters for Counters.Counter;\n\n    // Role definitions\n    bytes32 public constant PROPERTY_MANAGER_ROLE = keccak256(\"PROPERTY_MANAGER_ROLE\");\n    bytes32 public constant ESCROW_MANAGER_ROLE = keccak256(\"ESCROW_MANAGER_ROLE\");\n    bytes32 public constant GOVERNANCE_ROLE = keccak256(\"GOVERNANCE_ROLE\");\n\n    // Counter for NFT token IDs\n    Counters.Counter private _tokenIdCounter;\n\n    // USDC token contract\n    IERC20 public immutable USDC;\n    \n    // Escrow wallet for property purchases\n    address public immutable ESCROW_WALLET;\n    \n    // Price per NFT in USDC (6 decimals)\n    uint256 public constant NFT_PRICE = 1000 * 10**6; // 1000 USDC\n    \n    // Maximum total NFTs per property\n    uint256 public constant MAX_NFTS_PER_PROPERTY = 2500;\n\n    // Management fee structure (in basis points)\n    struct ManagementFees {\n        uint256 baseManagement;      // 1200 = 12%\n        uint256 technologyPlatform;  // 200 = 2%\n        uint256 complianceReporting; // 100 = 1%\n        uint256 total;              // 1500 = 15%\n    }\n    \n    ManagementFees public managementFees = ManagementFees({\n        baseManagement: 1200,\n        technologyPlatform: 200,\n        complianceReporting: 100,\n        total: 1500\n    });\n\n    // Property information\n    struct PropertyInfo {\n        uint256 propertyId;\n        string propertyAddress;\n        uint256 purchasePrice;\n        uint256 totalNFTs;\n        uint256 soldNFTs;\n        bool isActive;\n        uint256 createdAt;\n    }\n\n    // Ownership details for each NFT\n    struct OwnershipDetails {\n        uint256 tokenId;\n        uint256 propertyId;\n        address owner;\n        uint256 purchaseTimestamp;\n        uint256 ownershipPercentage; // In basis points (10000 = 100%)\n    }\n\n    // Profit distribution records\n    struct DistributionRecord {\n        uint256 distributionId;\n        uint256 propertyId;\n        uint256 totalProfit;\n        uint256 managementFee;\n        uint256 distributedAmount;\n        uint256 distributionDate;\n        mapping(address => uint256) individualClaims;\n        mapping(address => bool) hasClaimed;\n    }\n\n    // Governance proposal structure\n    struct Proposal {\n        uint256 proposalId;\n        uint256 propertyId;\n        string title;\n        string description;\n        ProposalType proposalType;\n        uint256 votingDeadline;\n        uint256 requiredQuorum;\n        uint256 votesFor;\n        uint256 votesAgainst;\n        uint256 totalVotingPower;\n        bool executed;\n        bool passed;\n        mapping(address => bool) hasVoted;\n        mapping(address => uint256) votingPower;\n    }\n\n    enum ProposalType {\n        PROPERTY_ACQUISITION,\n        MAJOR_RENOVATION,\n        PROPERTY_SALE,\n        MANAGEMENT_CONTRACT_RENEWAL,\n        PROFIT_DISTRIBUTION_CHANGE,\n        GMBH_DIRECTOR_APPOINTMENT,\n        EMERGENCY_ACTION\n    }\n\n    // State variables\n    mapping(uint256 => PropertyInfo) public properties;\n    mapping(uint256 => OwnershipDetails) public tokenOwnership;\n    mapping(uint256 => DistributionRecord) public distributionRecords;\n    mapping(uint256 => Proposal) public proposals;\n    \n    uint256 public nextPropertyId = 1;\n    uint256 public nextProposalId = 1;\n    uint256 public nextDistributionId = 1;\n\n    // Events\n    event PropertyAdded(uint256 indexed propertyId, string propertyAddress, uint256 totalNFTs);\n    event BeneficialOwnershipPurchased(address indexed buyer, uint256 indexed tokenId, uint256 indexed propertyId, uint256 price);\n    event ProfitDistributed(uint256 indexed distributionId, uint256 indexed propertyId, uint256 totalProfit, uint256 distributedAmount);\n    event ProfitsClaimed(address indexed claimer, uint256 indexed distributionId, uint256 amount);\n    event ProposalCreated(uint256 indexed proposalId, uint256 indexed propertyId, ProposalType proposalType, address proposer);\n    event VoteCast(uint256 indexed proposalId, address indexed voter, bool support, uint256 votingPower);\n    event ProposalExecuted(uint256 indexed proposalId, bool passed);\n\n    constructor(\n        string memory name,\n        string memory symbol,\n        address _usdcAddress,\n        address _escrowWallet\n    ) ERC721(name, symbol) {\n        require(_usdcAddress != address(0), \"Invalid USDC address\");\n        require(_escrowWallet != address(0), \"Invalid escrow wallet\");\n        \n        USDC = IERC20(_usdcAddress);\n        ESCROW_WALLET = _escrowWallet;\n        \n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _grantRole(PROPERTY_MANAGER_ROLE, msg.sender);\n        _grantRole(GOVERNANCE_ROLE, msg.sender);\n    }\n\n    /**\n     * @dev Add a new property for beneficial ownership\n     * @param propertyAddress Physical address of the property\n     * @param purchasePrice Total purchase price of the property\n     * @param totalNFTs Number of NFTs representing ownership shares\n     */\n    function addProperty(\n        string memory propertyAddress,\n        uint256 purchasePrice,\n        uint256 totalNFTs\n    ) external onlyRole(PROPERTY_MANAGER_ROLE) {\n        require(totalNFTs <= MAX_NFTS_PER_PROPERTY, \"Exceeds maximum NFTs per property\");\n        require(totalNFTs > 0, \"Total NFTs must be greater than 0\");\n        require(bytes(propertyAddress).length > 0, \"Property address cannot be empty\");\n\n        uint256 propertyId = nextPropertyId++;\n        \n        properties[propertyId] = PropertyInfo({\n            propertyId: propertyId,\n            propertyAddress: propertyAddress,\n            purchasePrice: purchasePrice,\n            totalNFTs: totalNFTs,\n            soldNFTs: 0,\n            isActive: true,\n            createdAt: block.timestamp\n        });\n\n        emit PropertyAdded(propertyId, propertyAddress, totalNFTs);\n    }\n\n    /**\n     * @dev Purchase beneficial ownership in a German GmbH property company\n     * @param propertyId ID of the property to purchase ownership in\n     */\n    function purchaseBeneficialOwnership(uint256 propertyId) \n        external \n        nonReentrant \n        whenNotPaused \n    {\n        PropertyInfo storage property = properties[propertyId];\n        require(property.isActive, \"Property not active\");\n        require(property.soldNFTs < property.totalNFTs, \"All ownership shares sold\");\n\n        // Transfer USDC to escrow wallet\n        require(\n            USDC.transferFrom(msg.sender, ESCROW_WALLET, NFT_PRICE),\n            \"USDC transfer failed\"\n        );\n\n        // Mint NFT\n        uint256 tokenId = _tokenIdCounter.current();\n        _tokenIdCounter.increment();\n        _safeMint(msg.sender, tokenId);\n\n        // Calculate ownership percentage\n        uint256 ownershipPercentage = (10000 * 1) / property.totalNFTs; // 10000 = 100%\n\n        // Record ownership details\n        tokenOwnership[tokenId] = OwnershipDetails({\n            tokenId: tokenId,\n            propertyId: propertyId,\n            owner: msg.sender,\n            purchaseTimestamp: block.timestamp,\n            ownershipPercentage: ownershipPercentage\n        });\n\n        // Update property state\n        property.soldNFTs++;\n\n        emit BeneficialOwnershipPurchased(msg.sender, tokenId, propertyId, NFT_PRICE);\n    }\n\n    /**\n     * @dev Distribute monthly profits to beneficial owners\n     * @param propertyId ID of the property generating profits\n     * @param totalRentalIncome Total rental income for the month\n     */\n    function distributeMonthlyProfits(uint256 propertyId, uint256 totalRentalIncome)\n        external\n        onlyRole(PROPERTY_MANAGER_ROLE)\n        nonReentrant\n    {\n        PropertyInfo storage property = properties[propertyId];\n        require(property.isActive, \"Property not active\");\n        require(totalRentalIncome > 0, \"Rental income must be greater than 0\");\n\n        // Calculate management fee (15%)\n        uint256 managementFee = (totalRentalIncome * managementFees.total) / 10000;\n        uint256 profitForDistribution = totalRentalIncome - managementFee;\n\n        uint256 distributionId = nextDistributionId++;\n        DistributionRecord storage distribution = distributionRecords[distributionId];\n        \n        distribution.distributionId = distributionId;\n        distribution.propertyId = propertyId;\n        distribution.totalProfit = totalRentalIncome;\n        distribution.managementFee = managementFee;\n        distribution.distributedAmount = profitForDistribution;\n        distribution.distributionDate = block.timestamp;\n\n        // Calculate individual claims based on NFT ownership\n        for (uint256 i = 0; i < totalSupply(); i++) {\n            uint256 tokenId = tokenByIndex(i);\n            if (tokenOwnership[tokenId].propertyId == propertyId) {\n                address owner = ownerOf(tokenId);\n                uint256 ownershipPercentage = tokenOwnership[tokenId].ownershipPercentage;\n                uint256 individualClaim = (profitForDistribution * ownershipPercentage) / 10000;\n                \n                distribution.individualClaims[owner] += individualClaim;\n            }\n        }\n\n        emit ProfitDistributed(distributionId, propertyId, totalRentalIncome, profitForDistribution);\n    }\n\n    /**\n     * @dev Claim profits from a distribution\n     * @param distributionId ID of the distribution to claim from\n     */\n    function claimProfits(uint256 distributionId) external nonReentrant {\n        DistributionRecord storage distribution = distributionRecords[distributionId];\n        require(!distribution.hasClaimed[msg.sender], \"Already claimed\");\n        \n        uint256 claimAmount = distribution.individualClaims[msg.sender];\n        require(claimAmount > 0, \"No profits to claim\");\n\n        distribution.hasClaimed[msg.sender] = true;\n\n        // Transfer profits (assuming contract holds USDC for distributions)\n        require(USDC.transfer(msg.sender, claimAmount), \"Profit transfer failed\");\n\n        emit ProfitsClaimed(msg.sender, distributionId, claimAmount);\n    }\n\n    /**\n     * @dev Create a governance proposal\n     * @param propertyId ID of the property (0 for general proposals)\n     * @param title Title of the proposal\n     * @param description Detailed description of the proposal\n     * @param proposalType Type of proposal\n     * @param votingPeriod Duration of voting in seconds\n     */\n    function createProposal(\n        uint256 propertyId,\n        string memory title,\n        string memory description,\n        ProposalType proposalType,\n        uint256 votingPeriod\n    ) external {\n        require(balanceOf(msg.sender) > 0, \"Must own NFTs to create proposals\");\n        require(bytes(title).length > 0, \"Title cannot be empty\");\n        require(votingPeriod >= 1 days && votingPeriod <= 30 days, \"Invalid voting period\");\n\n        uint256 proposalId = nextProposalId++;\n        Proposal storage proposal = proposals[proposalId];\n        \n        proposal.proposalId = proposalId;\n        proposal.propertyId = propertyId;\n        proposal.title = title;\n        proposal.description = description;\n        proposal.proposalType = proposalType;\n        proposal.votingDeadline = block.timestamp + votingPeriod;\n        proposal.requiredQuorum = _calculateQuorum(proposalType);\n        proposal.executed = false;\n        proposal.passed = false;\n\n        emit ProposalCreated(proposalId, propertyId, proposalType, msg.sender);\n    }\n\n    /**\n     * @dev Vote on a governance proposal\n     * @param proposalId ID of the proposal to vote on\n     * @param support True for yes, false for no\n     */\n    function vote(uint256 proposalId, bool support) external {\n        Proposal storage proposal = proposals[proposalId];\n        require(block.timestamp <= proposal.votingDeadline, \"Voting period ended\");\n        require(!proposal.hasVoted[msg.sender], \"Already voted\");\n        require(!proposal.executed, \"Proposal already executed\");\n\n        uint256 votingPower = _calculateVotingPower(msg.sender, proposal.propertyId);\n        require(votingPower > 0, \"No voting power\");\n\n        proposal.hasVoted[msg.sender] = true;\n        proposal.votingPower[msg.sender] = votingPower;\n        proposal.totalVotingPower += votingPower;\n\n        if (support) {\n            proposal.votesFor += votingPower;\n        } else {\n            proposal.votesAgainst += votingPower;\n        }\n\n        emit VoteCast(proposalId, msg.sender, support, votingPower);\n    }\n\n    /**\n     * @dev Execute a governance proposal\n     * @param proposalId ID of the proposal to execute\n     */\n    function executeProposal(uint256 proposalId) external {\n        Proposal storage proposal = proposals[proposalId];\n        require(block.timestamp > proposal.votingDeadline, \"Voting period not ended\");\n        require(!proposal.executed, \"Proposal already executed\");\n        require(proposal.totalVotingPower >= proposal.requiredQuorum, \"Quorum not met\");\n\n        proposal.executed = true;\n        proposal.passed = proposal.votesFor > proposal.votesAgainst;\n\n        emit ProposalExecuted(proposalId, proposal.passed);\n\n        // Additional execution logic would be implemented based on proposal type\n        if (proposal.passed) {\n            _executeProposalAction(proposalId);\n        }\n    }\n\n    /**\n     * @dev Get ownership percentage for an address\n     * @param owner Address to check ownership for\n     * @return Ownership percentage in basis points\n     */\n    function getOwnershipPercentage(address owner) external view returns (uint256) {\n        uint256 totalOwnership = 0;\n        uint256 balance = balanceOf(owner);\n        \n        for (uint256 i = 0; i < balance; i++) {\n            uint256 tokenId = tokenOfOwnerByIndex(owner, i);\n            totalOwnership += tokenOwnership[tokenId].ownershipPercentage;\n        }\n        \n        return totalOwnership;\n    }\n\n    /**\n     * @dev Calculate voting power for an address\n     * @param voter Address to calculate voting power for\n     * @param propertyId Property ID (0 for general proposals)\n     * @return Voting power based on NFT holdings\n     */\n    function _calculateVotingPower(address voter, uint256 propertyId) internal view returns (uint256) {\n        uint256 votingPower = 0;\n        uint256 balance = balanceOf(voter);\n        \n        for (uint256 i = 0; i < balance; i++) {\n            uint256 tokenId = tokenOfOwnerByIndex(voter, i);\n            if (propertyId == 0 || tokenOwnership[tokenId].propertyId == propertyId) {\n                votingPower += tokenOwnership[tokenId].ownershipPercentage;\n            }\n        }\n        \n        return votingPower;\n    }\n\n    /**\n     * @dev Calculate required quorum for proposal type\n     * @param proposalType Type of proposal\n     * @return Required quorum in basis points\n     */\n    function _calculateQuorum(ProposalType proposalType) internal pure returns (uint256) {\n        if (proposalType == ProposalType.EMERGENCY_ACTION) {\n            return 1000; // 10%\n        } else if (proposalType == ProposalType.PROPERTY_SALE) {\n            return 5000; // 50%\n        } else {\n            return 2500; // 25%\n        }\n    }\n\n    /**\n     * @dev Execute proposal action based on type\n     * @param proposalId ID of the proposal to execute\n     */\n    function _executeProposalAction(uint256 proposalId) internal {\n        // Implementation would depend on proposal type\n        // This is a placeholder for actual execution logic\n    }\n\n    // Emergency functions\n    function pause() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        _pause();\n    }\n\n    function unpause() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        _unpause();\n    }\n\n    // Override functions required by Solidity\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        uint256 batchSize\n    ) internal override(ERC721, ERC721Enumerable) whenNotPaused {\n        super._beforeTokenTransfer(from, to, tokenId, batchSize);\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721, ERC721Enumerable, AccessControl)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n\n    // View functions for transparency\n    function getPropertyInfo(uint256 propertyId) external view returns (PropertyInfo memory) {\n        return properties[propertyId];\n    }\n\n    function getTokenOwnership(uint256 tokenId) external view returns (OwnershipDetails memory) {\n        return tokenOwnership[tokenId];\n    }\n\n    function getDistributionInfo(uint256 distributionId) external view returns (\n        uint256,\n        uint256,\n        uint256,\n        uint256,\n        uint256,\n        uint256\n    ) {\n        DistributionRecord storage dist = distributionRecords[distributionId];\n        return (\n            dist.distributionId,\n            dist.propertyId,\n            dist.totalProfit,\n            dist.managementFee,\n            dist.distributedAmount,\n            dist.distributionDate\n        );\n    }\n\n    function getProposalInfo(uint256 proposalId) external view returns (\n        uint256,\n        uint256,\n        string memory,\n        string memory,\n        ProposalType,\n        uint256,\n        uint256,\n        uint256,\n        uint256,\n        bool,\n        bool\n    ) {\n        Proposal storage prop = proposals[proposalId];\n        return (\n            prop.proposalId,\n            prop.propertyId,\n            prop.title,\n            prop.description,\n            prop.proposalType,\n            prop.votingDeadline,\n            prop.requiredQuorum,\n            prop.votesFor,\n            prop.votesAgainst,\n            prop.executed,\n            prop.passed\n        );\n    }\n}